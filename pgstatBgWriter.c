/*
 * pgstatBgWriter MIB group implementation
 *
 * Note: this file originally auto-generated by mib2c
 */

#include "pgstatmibd.h"
#include "pgstatBgWriter.h"

//#include "util_funcs/header_generic.h"

static oid pgstatBgWriter_oid[] = { 1, 3, 6, 1, 4, 1, 27645, 3, 10 };

struct variable1 pgstatBgWriter_vars[] = {
    {PGSTATBGWRITER_CHECKPOINTSTIMED, 		ASN_COUNTER, RONLY, getvalue, 1, {1}},
    {PGSTATBGWRITER_CHECKPOINTSREQUESTED, 	ASN_COUNTER, RONLY, getvalue, 1, {2}},
    {PGSTATBGWRITER_BUFFERSCHECKPOINT, 		ASN_COUNTER, RONLY, getvalue, 1, {3}},
    {PGSTATBGWRITER_BUFFERSCLEAN, 			ASN_COUNTER, RONLY, getvalue, 1, {4}},
    {PGSTATBGWRITER_MAXWRITTENCLEAN, 		ASN_COUNTER, RONLY, getvalue, 1, {5}},
    {PGSTATBGWRITER_BUFFERSBACKEND, 		ASN_COUNTER, RONLY, getvalue, 1, {6}},
    {PGSTATBGWRITER_BUFFERSALLOCATED, 		ASN_COUNTER, RONLY, getvalue, 1, {7}}
};

void
init_pgstatBgWriter(void)
{
    DEBUGMSGTL((PGSTATBGWRITER_NAME, "Initializing\n"));
    REGISTER_MIB(PGSTATBGWRITER_NAME, pgstatBgWriter_vars, variable1, pgstatBgWriter_oid);
}

// TODO: put it all on a struct (pgstatBgWriterCache ?)
static u_long checkpoints_timed = 0;
static u_long checkpoints_req = 0;
static u_long buffers_checkpoint = 0;
static u_long buffers_clean = 0;
static u_long maxwritten_clean = 0;
static u_long buffers_backend = 0;
static u_long buffers_alloc = 0;

/**
 * refresh numbers
 */
void
refreshNumbers(void) {

	// TODO: cache these numbers to prevent going to database so frequently

	loadNumbersFromDB();
}

/**
 * load counters from database
 */
void
loadNumbersFromDB(void) {
	PGresult *res;

    printf("loadNumbersFromDB\n");

	res = PQexec(dbconn, "\
SELECT checkpoints_timed, checkpoints_req, \
	buffers_checkpoint, buffers_clean, \
	maxwritten_clean, buffers_backend, buffers_alloc \
FROM pg_stat_bgwriter");

	if (PQresultStatus(res) != PGRES_TUPLES_OK)
	{
		// TODO: improve exception handling
		fprintf(stderr, "SELECT command failed: %s", PQerrorMessage(dbconn));
		PQclear(res);
		//exit_nicely(conn);
	}

	checkpoints_timed = atoi(PQgetvalue(res, 0, 0));
	checkpoints_req = atoi(PQgetvalue(res, 0, 1));
	buffers_checkpoint = atoi(PQgetvalue(res, 0, 2));
	buffers_clean = atoi(PQgetvalue(res, 0, 3));
	maxwritten_clean = atoi(PQgetvalue(res, 0, 4));
	buffers_backend = atoi(PQgetvalue(res, 0, 5));
	buffers_alloc = atoi(PQgetvalue(res, 0, 6));

	PQclear(res);
}

u_char *
getvalue(struct variable *vp,
            oid * name,
            size_t * length,
            int exact, size_t * var_len, WriteMethod ** write_method)
{
    //static long long_ret;

    DEBUGMSGTL((PGSTATBGWRITER_NAME, "getvalue(%d)\n", vp->magic));
	printf("getvalue(%d)\n", vp->magic);

    if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED)
        return NULL;

	// TODO: make a better bound checking routine!
	if (vp->magic >= 1 && vp->magic <= 7)
		refreshNumbers();

    switch (vp->magic) {
    case PGSTATBGWRITER_CHECKPOINTSTIMED:
        return (u_char *) & checkpoints_timed;
	case PGSTATBGWRITER_CHECKPOINTSREQUESTED:
        return (u_char *) & checkpoints_req;
	case PGSTATBGWRITER_BUFFERSCHECKPOINT:
        return (u_char *) & buffers_checkpoint;
	case PGSTATBGWRITER_BUFFERSCLEAN:
        return (u_char *) & buffers_clean;
	case PGSTATBGWRITER_MAXWRITTENCLEAN:
        return (u_char *) & maxwritten_clean;
	case PGSTATBGWRITER_BUFFERSBACKEND:
        return (u_char *) & buffers_backend;
	case PGSTATBGWRITER_BUFFERSALLOCATED:
        return (u_char *) & buffers_alloc;
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in %s\n", vp->magic, PGSTATBGWRITER_NAME));
    }

    return NULL;
}

