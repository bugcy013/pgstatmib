/*
 * Note: this file originally auto-generated by mib2c using
 *  : mib2c.table_data.conf 15999 2007-03-25 22:32:02Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "pgstatDatabaseTable2.h"

/** Initializes the pgstatDatabaseTable module */
void
init_pgstatDatabaseTable(void)
{
  /*
   * here we initialize all the tables we're planning on supporting
   */
  initialize_table_pgstatDatabaseTable ();
}

//# Determine the first/last column names

/** Initialize the pgstatDatabaseTable table by defining its contents and how it's structured */
void
initialize_table_pgstatDatabaseTable (void)
{
  static oid pgstatDatabaseTable_oid[] = { 1, 3, 6, 1, 4, 1, 27645, 3, 1 };
  size_t pgstatDatabaseTable_oid_len = OID_LENGTH (pgstatDatabaseTable_oid);

  netsnmp_handler_registration *reg;
  netsnmp_tdata *table_data;
  netsnmp_table_registration_info *table_info;
  netsnmp_cache *cache;

  reg =
    netsnmp_create_handler_registration ("pgstatDatabaseTable",
					 pgstatDatabaseTable_handler,
					 pgstatDatabaseTable_oid,
					 pgstatDatabaseTable_oid_len,
					 HANDLER_CAN_RONLY);

  table_data = netsnmp_tdata_create_table ("pgstatDatabaseTable", 0);
  table_info = SNMP_MALLOC_TYPEDEF (netsnmp_table_registration_info);

  netsnmp_table_helper_add_indexes (table_info, ASN_INTEGER,	/* index: pgstatDatabaseId */
				    0);

  table_info->min_column = COLUMN_PGSTATDATABASEID;
  table_info->max_column = COLUMN_PGSTATDATABASETUPLESMODIFIED;

  netsnmp_tdata_register (reg, table_data, table_info);
  cache = netsnmp_cache_create (PGSTATDATABASETABLE_TIMEOUT,
				pgstatDatabaseTable_load,
				pgstatDatabaseTable_free,
				pgstatDatabaseTable_oid,
				pgstatDatabaseTable_oid_len);

  cache->magic = (void *) table_data;

	printf("cache created: %d\n", (int) &cache);

  netsnmp_inject_handler_before (reg, netsnmp_cache_handler_get (cache),
				 TABLE_DATA_NAME);

  /*
   * Initialise the contents of the table here
   */
   
	printf("table registered: %d\n", (int) &table_info);
}

/*
 * Typical data structure for a row entry
 */
struct pgstatDatabaseTable_entry
{
  /*
   * Index values
   */
  long pgstatDatabaseId;

  /*
   * Column values
   */
  //long            pgstatDatabaseId;
  char pgstatDatabaseName[64];
  size_t pgstatDatabaseName_len;
  u_long pgstatDatabaseBackends;
  u_long pgstatDatabaseCommits;
  u_long pgstatDatabaseRollbacks;
  u_long pgstatDatabaseBlocksRead;
  u_long pgstatDatabaseBlocksHit;
  u_long pgstatDatabaseTuplesReturned;
  u_long pgstatDatabaseTuplesFetched;
  u_long pgstatDatabaseTuplesInserted;
  u_long pgstatDatabaseTuplesUpdated;
  u_long pgstatDatabaseTuplesDeleted;
  u_long pgstatDatabaseSizeMB;
  u_long pgstatDatabaseRollbackRatio;
  u_long pgstatDatabaseCacheHitRatio;
  u_long pgstatDatabaseTuplesModified;

  int valid;
};

/*
 * create a new row in the table
 */
netsnmp_tdata_row *
pgstatDatabaseTable_createEntry (netsnmp_tdata * table_data,
				 long pgstatDatabaseId)
{
  struct pgstatDatabaseTable_entry *entry;
  netsnmp_tdata_row *row;

  entry = SNMP_MALLOC_TYPEDEF (struct pgstatDatabaseTable_entry);
  if (!entry)
    return NULL;

	printf("creating entry: %d\n", (int) &entry);

  row = netsnmp_tdata_create_row ();
  if (!row)
    {
      SNMP_FREE (entry);
      return NULL;
    }
  row->data = entry;

  entry->pgstatDatabaseId = pgstatDatabaseId;
  netsnmp_tdata_row_add_index (row, ASN_INTEGER,
			       &(entry->pgstatDatabaseId),
			       sizeof (entry->pgstatDatabaseId));
  netsnmp_tdata_add_row (table_data, row);
  return row;
}

/*
 * remove a row from the table
 */
void
pgstatDatabaseTable_removeEntry (netsnmp_tdata * table_data,
				 netsnmp_tdata_row * row)
{
  struct pgstatDatabaseTable_entry *entry;

  if (!row)
    return;			/* Nothing to remove */
  entry = (struct pgstatDatabaseTable_entry *)
    netsnmp_tdata_remove_and_delete_row (table_data, row);

	printf("removing entry: %d\n", (int) &entry);

  if (entry)
    SNMP_FREE (entry);		/* XXX - release any other internal resources */
}

#define STRMAX	255

/*
 * Example cache handling - set up table_data list from a suitable file
 */
int
pgstatDatabaseTable_load (netsnmp_cache * cache, void *vmagic)
{
  netsnmp_tdata *table = (netsnmp_tdata *) vmagic;
  netsnmp_tdata_row *row;
  FILE *fp;
  char buf[STRMAX];
  fp = fopen ("/data/for/pgstatDatabaseTable", "r");

  long pgstatDatabaseId = 1;
  netsnmp_tdata_row *this;

	printf("loading cache: %d\n", (int) &cache);

  while (fgets (buf, STRMAX, fp))
    {
      /*
       * Unpick 'buf' to extract the index values...
       */
      this = pgstatDatabaseTable_createEntry (table, pgstatDatabaseId);
      /*
       * ... and then populate 'this' with the column values
       */
    }
  fclose (fp);
}

void
pgstatDatabaseTable_free (netsnmp_cache * cache, void *vmagic)
{
  netsnmp_tdata *table = (netsnmp_tdata *) vmagic;
  netsnmp_tdata_row *this;
  
	printf("freeing cache: %d\n", (int) &cache);
  
  while ((this = (void *) netsnmp_tdata_row_first (table)))
    //while ((this = (void*) netsnmp_tdata_get_first_row(table)))
    {
      netsnmp_tdata_remove_and_delete_row (table, this);
    }
}

/** handles requests for the pgstatDatabaseTable table */
int
pgstatDatabaseTable_handler (netsnmp_mib_handler * handler,
			     netsnmp_handler_registration * reginfo,
			     netsnmp_agent_request_info * reqinfo,
			     netsnmp_request_info * requests)
{

  netsnmp_request_info *request;
  netsnmp_table_request_info *table_info;
  netsnmp_tdata *table_data;
  netsnmp_tdata_row *table_row;
  struct pgstatDatabaseTable_entry *table_entry;
  int ret;

	printf("handling request: %d\n", reqinfo->mode);

  switch (reqinfo->mode)
    {
      /*
       * Read-support (also covers GetNext requests)
       */
    case MODE_GET:
      for (request = requests; request; request = request->next)
	{
	  table_entry = (struct pgstatDatabaseTable_entry *)
	    netsnmp_tdata_extract_entry (request);
	  table_info = netsnmp_extract_table_info (request);

	  switch (table_info->colnum)
	    {
	    case COLUMN_PGSTATDATABASEID:
	      if (!table_entry)
		{
		  netsnmp_set_request_error (reqinfo,
					     request, SNMP_NOSUCHINSTANCE);
		  continue;
		}
	      snmp_set_var_typed_integer (request->requestvb,
					  ASN_INTEGER,
					  table_entry->pgstatDatabaseId);
	      break;
	    case COLUMN_PGSTATDATABASENAME:
	      if (!table_entry)
		{
		  netsnmp_set_request_error (reqinfo,
					     request, SNMP_NOSUCHINSTANCE);
		  continue;
		}
	      snmp_set_var_typed_value (request->requestvb,
					ASN_OCTET_STR,
					(u_char *)
					table_entry->pgstatDatabaseName,
					table_entry->pgstatDatabaseName_len);
	      break;
	    case COLUMN_PGSTATDATABASEBACKENDS:
	      if (!table_entry)
		{
		  netsnmp_set_request_error (reqinfo,
					     request, SNMP_NOSUCHINSTANCE);
		  continue;
		}
	      snmp_set_var_typed_integer (request->requestvb,
					  ASN_GAUGE,
					  table_entry->pgstatDatabaseBackends);
	      break;
	    case COLUMN_PGSTATDATABASECOMMITS:
	      if (!table_entry)
		{
		  netsnmp_set_request_error (reqinfo,
					     request, SNMP_NOSUCHINSTANCE);
		  continue;
		}
	      snmp_set_var_typed_integer (request->requestvb,
					  ASN_COUNTER,
					  table_entry->pgstatDatabaseCommits);
	      break;
	    case COLUMN_PGSTATDATABASEROLLBACKS:
	      if (!table_entry)
		{
		  netsnmp_set_request_error (reqinfo,
					     request, SNMP_NOSUCHINSTANCE);
		  continue;
		}
	      snmp_set_var_typed_integer (request->requestvb,
					  ASN_COUNTER,
					  table_entry->pgstatDatabaseRollbacks);
	      break;
	    case COLUMN_PGSTATDATABASEBLOCKSREAD:
	      if (!table_entry)
		{
		  netsnmp_set_request_error (reqinfo,
					     request, SNMP_NOSUCHINSTANCE);
		  continue;
		}
	      snmp_set_var_typed_integer (request->requestvb,
					  ASN_COUNTER,
					  table_entry->pgstatDatabaseBlocksRead);
	      break;
	    case COLUMN_PGSTATDATABASEBLOCKSHIT:
	      if (!table_entry)
		{
		  netsnmp_set_request_error (reqinfo,
					     request, SNMP_NOSUCHINSTANCE);
		  continue;
		}
	      snmp_set_var_typed_integer (request->requestvb,
					  ASN_COUNTER,
					  table_entry->pgstatDatabaseBlocksHit);
	      break;
	    case COLUMN_PGSTATDATABASETUPLESRETURNED:
	      if (!table_entry)
		{
		  netsnmp_set_request_error (reqinfo,
					     request, SNMP_NOSUCHINSTANCE);
		  continue;
		}
	      snmp_set_var_typed_integer (request->requestvb,
					  ASN_COUNTER,
					  table_entry->pgstatDatabaseTuplesReturned);
	      break;
	    case COLUMN_PGSTATDATABASETUPLESFETCHED:
	      if (!table_entry)
		{
		  netsnmp_set_request_error (reqinfo,
					     request, SNMP_NOSUCHINSTANCE);
		  continue;
		}
	      snmp_set_var_typed_integer (request->requestvb,
					  ASN_COUNTER,
					  table_entry->pgstatDatabaseTuplesFetched);
	      break;
	    case COLUMN_PGSTATDATABASETUPLESINSERTED:
	      if (!table_entry)
		{
		  netsnmp_set_request_error (reqinfo,
					     request, SNMP_NOSUCHINSTANCE);
		  continue;
		}
	      snmp_set_var_typed_integer (request->requestvb,
					  ASN_COUNTER,
					  table_entry->pgstatDatabaseTuplesInserted);
	      break;
	    case COLUMN_PGSTATDATABASETUPLESUPDATED:
	      if (!table_entry)
		{
		  netsnmp_set_request_error (reqinfo,
					     request, SNMP_NOSUCHINSTANCE);
		  continue;
		}
	      snmp_set_var_typed_integer (request->requestvb,
					  ASN_COUNTER,
					  table_entry->pgstatDatabaseTuplesUpdated);
	      break;
	    case COLUMN_PGSTATDATABASETUPLESDELETED:
	      if (!table_entry)
		{
		  netsnmp_set_request_error (reqinfo,
					     request, SNMP_NOSUCHINSTANCE);
		  continue;
		}
	      snmp_set_var_typed_integer (request->requestvb,
					  ASN_COUNTER,
					  table_entry->pgstatDatabaseTuplesDeleted);
	      break;
	    case COLUMN_PGSTATDATABASESIZEMB:
	      if (!table_entry)
		{
		  netsnmp_set_request_error (reqinfo,
					     request, SNMP_NOSUCHINSTANCE);
		  continue;
		}
	      snmp_set_var_typed_integer (request->requestvb,
					  ASN_UNSIGNED,
					  table_entry->pgstatDatabaseSizeMB);
	      break;
	    case COLUMN_PGSTATDATABASEROLLBACKRATIO:
	      if (!table_entry)
		{
		  netsnmp_set_request_error (reqinfo,
					     request, SNMP_NOSUCHINSTANCE);
		  continue;
		}
	      snmp_set_var_typed_integer (request->requestvb,
					  ASN_UNSIGNED,
					  table_entry->pgstatDatabaseRollbackRatio);
	      break;
	    case COLUMN_PGSTATDATABASECACHEHITRATIO:
	      if (!table_entry)
		{
		  netsnmp_set_request_error (reqinfo,
					     request, SNMP_NOSUCHINSTANCE);
		  continue;
		}
	      snmp_set_var_typed_integer (request->requestvb,
					  ASN_UNSIGNED,
					  table_entry->pgstatDatabaseCacheHitRatio);
	      break;
	    case COLUMN_PGSTATDATABASETUPLESMODIFIED:
	      if (!table_entry)
		{
		  netsnmp_set_request_error (reqinfo,
					     request, SNMP_NOSUCHINSTANCE);
		  continue;
		}
	      snmp_set_var_typed_integer (request->requestvb,
					  ASN_COUNTER,
					  table_entry->pgstatDatabaseTuplesModified);
	      break;
	    default:
	      netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHOBJECT);
	      break;
	    }
	}
      break;

    }
  return SNMP_ERR_NOERROR;
}
